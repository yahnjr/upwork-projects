<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Circle Area Selector</title>
    <script src='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css' rel='stylesheet' />
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        
        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
        
        .info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            max-width: 300px;
            transition: all 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .info-panel.expanded {
            max-width: 400px;
        }
        
        .status {
            font-weight: bold;
            color: #2563eb;
            margin-bottom: 10px;
        }
        
        .instructions {
            font-size: 14px;
            color: #666;
            line-height: 1.4;
        }
        
        .area-info {
            margin-top: 10px;
            padding: 10px;
            background: #f0f9ff;
            border-radius: 4px;
            border-left: 3px solid #2563eb;
        }
        
        .saved-area {
            background: #f0fdf4;
            border-left-color: #16a34a;
        }
        
        .controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #2563eb;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #1d4ed8;
        }
        
        button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }
        
        .clear-btn {
            background: #dc2626;
        }
        
        .clear-btn:hover {
            background: #b91c1c;
        }
        
        .data-options {
            margin-top: 15px;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .data-options.visible {
            opacity: 1;
            max-height: 800px;
        }
        
        .data-options h3 {
            margin: 0 0 15px 0;
            color: #374151;
            font-size: 16px;
            font-weight: 600;
        }
        
        .data-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .data-button {
            padding: 15px 10px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
            font-size: 13px;
            font-weight: 500;
            color: #475569;
        }
        
        .data-button:hover {
            border-color: #2563eb;
            background: #eff6ff;
            color: #2563eb;
        }
        
        .data-button.selected {
            background: #2563eb;
            border-color: #2563eb;
            color: white;
        }
        
        .data-button.selected:hover {
            background: #1d4ed8;
            border-color: #1d4ed8;
        }
        
        .data-button.loading {
            opacity: 0.7;
            cursor: wait;
        }
        
        .data-results {
            margin-top: 15px;
            background: #f8fafc;
            border-radius: 6px;
            padding: 15px;
            border: 1px solid #e2e8f0;
        }
        
        .data-results h4 {
            margin: 0 0 10px 0;
            color: #374151;
            font-size: 14px;
            font-weight: 600;
        }
        
        .data-count {
            font-size: 18px;
            font-weight: bold;
            color: #2563eb;
        }
        
        .data-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        
        .data-item {
            padding: 8px;
            background: white;
            border-radius: 4px;
            margin-bottom: 5px;
            font-size: 12px;
            border-left: 3px solid #2563eb;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #2563eb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error-message {
            color: #dc2626;
            font-size: 12px;
            margin-top: 5px;
        }
        
        .filter-bar-container {
            margin-top: 10px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .filter-bar-label {
            font-size: 12px;
            color: #374151;
            min-width: 40px;
        }
        .filter-bar {
            position: relative;
            height: 18px;
            flex: 1;
            border-radius: 8px;
            background: linear-gradient(90deg, #fee5d9 0%, #fc9272 50%, #de2d26 100%);
            box-shadow: 0 1px 3px rgba(0,0,0,0.07);
            cursor: pointer;
        }
        .filter-bar[data-type="air-quality"] {
            background: linear-gradient(90deg, #edf8e9 0%, #74c476 50%, #238b45 100%);
        }
        .filter-bar[data-type="walkability"] {
            background: linear-gradient(90deg, #e0f2fe 0%, #2563eb 100%);
        }
        .filter-bar-handle {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 18px;
            height: 18px;
            background: #fff;
            border: 2px solid #2563eb;
            border-radius: 50%;
            box-shadow: 0 2px 6px rgba(0,0,0,0.12);
            cursor: grab;
            transition: border 0.2s;
            z-index: 2;
        }
        .filter-bar-handle.active {
            border: 2px solid #1d4ed8;
        }
        .filter-bar-min-label {
            font-size: 12px;
            color: #2563eb;
            margin-left: 6px;
            min-width: 28px;
            text-align: left;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="info-panel" id="info-panel">
        <div class="status" id="status">Click anywhere on the map to start</div>
        <div class="instructions">
            <div id="instructions">Click on the map to place a circle (25 mile radius). Use mouse wheel to resize, then click again to save.</div>
        </div>
        <div id="area-info"></div>
        <div class="controls">
            <button id="clear-btn" class="clear-btn" disabled>Clear Area</button>
        </div>
        
        <div class="data-options" id="data-options">
            <h3>Data Analysis Options</h3>
            <div class="data-grid">
                <div class="data-button" data-type="crime">Crime</div>
                <div class="data-button" data-type="walkability">Walkability</div>
                <div class="data-button" data-type="air-quality">Air Quality</div>
                <div class="data-button" data-type="demographics">Demographics</div>
                <div class="data-button" data-type="properties">Properties</div>
                <div class="data-button" data-type="education">Education</div>
                <div class="data-button" data-type="transit">Transit</div>
                <div class="data-button" data-type="socialmedia">Social Media</div>
            </div>
            <div id="data-results"></div>
        </div>
    </div>

    <script>
        mapboxgl.accessToken = 'pk.eyJ1IjoiaWZvcm1haGVyIiwiYSI6ImNsaHBjcnAwNDF0OGkzbnBzZmUxM2Q2bXgifQ.fIyIgSwq1WWVk9CKlXRXiQ';
        
        // Initialize the map
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/streets-v11',
            center: [-74.0060, 40.7128], // New York City
            zoom: 10
        });
        
        // State variables
        let currentCircle = null;
        let isPlacingCircle = false;
        let currentRadius = 25; // Default 25 miles
        let areaOfInterest = null;
        let selectedDataTypes = new Set();
        let loadedData = {
            properties: null,
            socialmedia: null,
            census: null
        };
        let dataResults = {};
        let fetchedAreas = new Set();
        
        // UI elements
        const statusEl = document.getElementById('status');
        const instructionsEl = document.getElementById('instructions');
        const areaInfoEl = document.getElementById('area-info');
        const clearBtn = document.getElementById('clear-btn');
        const infoPanelEl = document.getElementById('info-panel');
        const dataOptionsEl = document.getElementById('data-options');
        const dataResultsEl = document.getElementById('data-results');
        
        // Convert miles to meters for Mapbox
        function milesToMeters(miles) {
            return miles * 1609.34;
        }
        
        // Convert meters to miles
        function metersToMiles(meters) {
            return meters / 1609.34;
        }
        
        // Create a circle polygon
        function createCircle(center, radiusInMiles) {
            const radiusInMeters = milesToMeters(radiusInMiles);
            const points = 64;
            const coords = [];
            
            for (let i = 0; i < points; i++) {
                const angle = (i / points) * 2 * Math.PI;
                const lat = center[1] + (radiusInMeters / 111320) * Math.cos(angle);
                const lng = center[0] + (radiusInMeters / (111320 * Math.cos(center[1] * Math.PI / 180))) * Math.sin(angle);
                coords.push([lng, lat]);
            }
            coords.push(coords[0]); // Close the polygon
            
            return {
                type: 'Polygon',
                coordinates: [coords]
            };
        }
        
        // Update circle on map
        function updateCircle(center, radiusInMiles) {
            const circleGeoJSON = createCircle(center, radiusInMiles);
            
            if (map.getSource('circle')) {
                map.getSource('circle').setData(circleGeoJSON);
            } else {
                map.addSource('circle', {
                    type: 'geojson',
                    data: circleGeoJSON
                });
                
                map.addLayer({
                    id: 'circle-fill',
                    type: 'fill',
                    source: 'circle',
                    paint: {
                        'fill-color': '#2563eb',
                        'fill-opacity': 0.2
                    }
                });
                
                map.addLayer({
                    id: 'circle-outline',
                    type: 'line',
                    source: 'circle',
                    paint: {
                        'line-color': '#2563eb',
                        'line-width': 2
                    }
                });
            }
        }
        
        // Fit map to circle bounds if needed
        function fitMapToCircle(center, radiusInMiles) {
            const radiusInMeters = milesToMeters(radiusInMiles);
            const R = 6378137; // Earth radius in meters
            const lat = center[1] * Math.PI / 180;
            const lon = center[0] * Math.PI / 180;
            const dLat = radiusInMeters / R;
            const dLon = radiusInMeters / (R * Math.cos(lat));
            const minLat = center[1] - dLat * 180 / Math.PI;
            const maxLat = center[1] + dLat * 180 / Math.PI;
            const minLon = center[0] - dLon * 180 / Math.PI;
            const maxLon = center[0] + dLon * 180 / Math.PI;
            const bounds = [
                [minLon, minLat],
                [maxLon, maxLat]
            ];
            map.fitBounds(bounds, { padding: 40, maxZoom: 12 });
        }
        
        // Load GeoJSON data
        async function loadGeoJSONData() {
            try {
                // Load properties data
                const propertiesResponse = await fetch('data/properties.geojson');
                if (propertiesResponse.ok) {
                    loadedData.properties = await propertiesResponse.json();
                    console.log('Properties data loaded:', loadedData.properties.features.length, 'features');
                }
                
                // Load social media data
                const socialMediaResponse = await fetch('data/LocalSocialMedia.geojson');
                if (socialMediaResponse.ok) {
                    loadedData.socialmedia = await socialMediaResponse.json();
                    console.log('Social media data loaded:', loadedData.socialmedia.features.length, 'features');
                }
            } catch (error) {
                console.warn('Could not load GeoJSON files:', error);
            }
        }
        
        // Fetch census data for area
        function fetchCensusDataForArea(coordinates) {
            const areaKey = `${Math.round(coordinates[0] * 100) / 100}-${Math.round(coordinates[1] * 100) / 100}`;
            if (fetchedAreas.has(areaKey)) {
                console.log(`Census data for area ${areaKey} already fetched`);
                return Promise.resolve();
            }
            
            console.log(`Initiating fetch for census data around coordinates: [${coordinates[0]}, ${coordinates[1]}]`);
            fetchedAreas.add(areaKey);
            
            const radius = 0.3;
            const bounds = {
                west: coordinates[0] - radius,
                south: coordinates[1] - radius,
                east: coordinates[0] + radius,
                north: coordinates[1] + radius
            };
            
            const geometry = `${bounds.west},${bounds.south},${bounds.east},${bounds.north}`;
            const baseUrl = 'https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/tigerWMS_Current/MapServer/14/query?';
            const url = new URL(baseUrl);
            url.searchParams.append('geometry', geometry);
            url.searchParams.append('geometryType', 'esriGeometryEnvelope');
            url.searchParams.append('spatialRel', 'esriSpatialRelIntersects');
            url.searchParams.append('inSR', '4326');
            url.searchParams.append('outFields', 'GEOID,NAME');
            url.searchParams.append('f', 'geojson');
            
            console.log("Fetching data from:", url.toString());
            
            return fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(censusData => {
                    console.log(`Received census data for area ${areaKey}.`, censusData);
                    
                    // Add mock data to each census tract
                    censusData.features.forEach(f => {
                        const GEOID = f.properties.GEOID;
                        const id = parseInt(GEOID, 10);
                        const lat = f.geometry && f.geometry.coordinates ? f.geometry.coordinates[0][0][1] || 0 : 0;
                        const lon = f.geometry && f.geometry.coordinates ? f.geometry.coordinates[0][0][0] || 0 : 0;
                        // Walkability: keep as is for good range
                        f.properties.Walkability = (id * 7 + 13) % 10;
                        // Crime: more variation using sin, id, and lon
                        f.properties.Crime = Math.abs(Math.round((Math.sin(id / 1000 + lon) * 5 + (id % 10) + (Math.random() * 3))));
                        // Air Quality: more variation using cos, id, lat, and random
                        f.properties.Air_Quality = Math.abs(Math.round((Math.cos(id / 500 + lat) * 4 + (id % 7) + (Math.random() * 4))));
                        f.properties.Walkability = Math.max(0, Math.min(10, f.properties.Walkability));
                        f.properties.Air_Quality = Math.max(0, Math.min(10, f.properties.Air_Quality));
                        f.properties.Crime = Math.max(0, Math.min(10, f.properties.Crime));
                    });
                    
                    // Store census data
                    if (!loadedData.census) {
                        loadedData.census = { type: 'FeatureCollection', features: [] };
                    }
                    
                    const existingGeoIds = new Set(loadedData.census.features.map(f => f.properties.GEOID));
                    const newFeatures = censusData.features.filter(f => !existingGeoIds.has(f.properties.GEOID));
                    loadedData.census.features.push(...newFeatures);
                    
                    console.log(`Added ${newFeatures.length} new census features to loaded data.`);
                    
                    return censusData;
                })
                .catch(error => {
                    console.error("Error fetching census data:", error);
                    fetchedAreas.delete(areaKey);
                    throw error;
                });
        }
        
        // Query Overpass API for education data
        async function queryEducationData(center, radiusInMiles) {
            const radiusInMeters = milesToMeters(radiusInMiles);
            const overpassQuery = `
                [out:json][timeout:25];
                (
                node["amenity"~"school|university|college|kindergarten"](around:${radiusInMeters},${center[1]},${center[0]});
                way["amenity"~"school|university|college|kindergarten"](around:${radiusInMeters},${center[1]},${center[0]});
                relation["amenity"~"school|university|college|kindergarten"](around:${radiusInMeters},${center[1]},${center[0]});
                );
                out geom;
            `;
            
            try {
                // Update button text to show fetching status
                const button = document.querySelector('[data-type="education"]');
                if (button) {
                    button.innerHTML = '<span class="loading-spinner"></span>Fetching...';
                }
                
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: overpassQuery,
                    headers: {
                        'Content-Type': 'text/plain'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                // Update button text to show processing status
                if (button) {
                    button.innerHTML = '<span class="loading-spinner"></span>Processing...';
                }
                
                const data = await response.json();
                
                // Convert OSM data to GeoJSON-like format for easier processing
                const features = data.elements.map(element => {
                    let geometry;
                    let coordinates;
                    
                    if (element.type === 'node') {
                        coordinates = [element.lon, element.lat];
                        geometry = { type: 'Point', coordinates };
                    } else if (element.type === 'way' && element.geometry) {
                        coordinates = element.geometry.map(node => [node.lon, node.lat]);
                        geometry = { type: 'LineString', coordinates };
                    } else {
                        return null; // Skip relations and ways without geometry for now
                    }
                    
                    return {
                        type: 'Feature',
                        geometry,
                        properties: {
                            ...element.tags,
                            osm_id: element.id,
                            osm_type: element.type
                        }
                    };
                }).filter(Boolean);
                
                return {
                    type: 'FeatureCollection',
                    features
                };
            } catch (error) {
                console.error('Error querying Overpass API:', error);
                throw error;
            }
        }
        
        // Filter features within circle using Turf.js
        function filterFeaturesInCircle(geojsonData, center, radiusInMiles) {
            if (!geojsonData || !geojsonData.features) return [];
            
            const circle = turf.circle(center, radiusInMiles, { units: 'miles' });
            const featuresWithin = [];
            
            geojsonData.features.forEach(feature => {
                try {
                    if (feature.geometry.type === 'Point') {
                        if (turf.booleanPointInPolygon(feature, circle)) {
                            featuresWithin.push(feature);
                        }
                    } else {
                        // For non-point geometries, check if they intersect with the circle
                        if (turf.booleanIntersects(feature, circle)) {
                            featuresWithin.push(feature);
                        }
                    }
                } catch (error) {
                    console.warn('Error checking feature intersection:', error, feature);
                }
            });
            
            return featuresWithin;
        }
        
        // Process census data for specific metric
        async function processCensusData(dataType) {
            if (!areaOfInterest) return [];
            
            try {
                // Fetch census data for the area if not already loaded
                await fetchCensusDataForArea(areaOfInterest.center);
                
                if (!loadedData.census) {
                    throw new Error('Census data not available');
                }
                
                // Filter census tracts within the area of interest
                const featuresInArea = filterFeaturesInCircle(
                    loadedData.census,
                    areaOfInterest.center,
                    areaOfInterest.radius
                );
                
                return featuresInArea;
            } catch (error) {
                console.error(`Error processing census data for ${dataType}:`, error);
                throw error;
            }
        }
        
        // Process data for a specific type
        async function processDataType(dataType) {
            if (!areaOfInterest) return;
            
            const button = document.querySelector(`[data-type="${dataType}"]`);
            button.classList.add('loading');
            
            // Add loading text for specific data types
            if (['crime', 'air-quality', 'walkability', 'education'].includes(dataType)) {
                button.innerHTML = '<span class="loading-spinner"></span>Querying...';
            }
            
            try {
                let features = [];
                
                switch (dataType) {
                    case 'properties':
                        if (loadedData.properties) {
                            features = filterFeaturesInCircle(
                                loadedData.properties, 
                                areaOfInterest.center, 
                                areaOfInterest.radius
                            );
                        }
                        break;
                        
                    case 'socialmedia':
                        if (loadedData.socialmedia) {
                            features = filterFeaturesInCircle(
                                loadedData.socialmedia, 
                                areaOfInterest.center, 
                                areaOfInterest.radius
                            );
                        }
                        break;
                        
                    case 'education':
                        const educationData = await queryEducationData(
                            areaOfInterest.center, 
                            areaOfInterest.radius
                        );
                        features = educationData.features;
                        break;
                        
                    case 'crime':
                    case 'air-quality':
                    case 'walkability':
                        features = await processCensusData(dataType);
                        break;
                }
                
                dataResults[dataType] = features;
                displayDataResults();
                
                // Add features to map
                addFeaturesToMap(dataType, features);
                
            } catch (error) {
                console.error(`Error processing ${dataType} data:`, error);
                dataResults[dataType] = { error: error.message };
                displayDataResults();
            } finally {
                button.classList.remove('loading');
                // Reset button text
                if (['crime', 'air-quality', 'walkability', 'education'].includes(dataType)) {
                    const displayName = dataType.split('-').map(word => 
                        word.charAt(0).toUpperCase() + word.slice(1)
                    ).join(' ');
                    button.innerHTML = displayName;
                }
            }
        }
        
        // Add features to map
        function addFeaturesToMap(dataType, features) {
            const sourceId = `${dataType}-data`;
            const layerId = `${dataType}-layer`;
            
            // Remove existing layer and source
            if (map.getLayer(layerId)) {
                map.removeLayer(layerId);
            }
            if (map.getSource(sourceId)) {
                map.removeSource(sourceId);
            }
            
            if (features.length === 0) return;
            
            // Add source
            map.addSource(sourceId, {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: features
                }
            });
            
            // Style based on data type
            const layerConfig = getLayerConfig(dataType);
            
            map.addLayer({
                id: layerId,
                type: layerConfig.type,
                source: sourceId,
                paint: layerConfig.paint,
                layout: layerConfig.layout || {}
            });
            
            // Add click handler for popups
            map.on('click', layerId, (e) => {
                const feature = e.features[0];
                const popup = createPopup(dataType, feature);
                new mapboxgl.Popup()
                    .setLngLat(e.lngLat)
                    .setHTML(popup)
                    .addTo(map);
            });
            
            // Change cursor on hover
            map.on('mouseenter', layerId, () => {
                map.getCanvas().style.cursor = 'pointer';
            });
            
            map.on('mouseleave', layerId, () => {
                map.getCanvas().style.cursor = '';
            });
        }
        
        // Get layer configuration for different data types
        function getLayerConfig(dataType) {
            const configs = {
                properties: {
                    type: 'circle',
                    paint: {
                        'circle-radius': 6,
                        'circle-color': '#dc2626',
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#ffffff'
                    }
                },
                socialmedia: {
                    type: 'circle',
                    paint: {
                        'circle-radius': 5,
                        'circle-color': '#7c3aed',
                        'circle-stroke-width': 1,
                        'circle-stroke-color': '#ffffff'
                    }
                },
                education: {
                    type: 'circle',
                    paint: {
                        'circle-radius': 7,
                        'circle-color': '#059669',
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#ffffff'
                    }
                },
                crime: {
                    type: 'fill',
                    paint: {
                        'fill-color': [
                            'interpolate',
                            ['linear'],
                            ['get', 'Crime'],
                            0, '#fee5d9',
                            5, '#fc9272',
                            10, '#de2d26'
                        ],
                        'fill-opacity': 0.6,
                        'fill-outline-color': '#333333'
                    }
                },
                'air-quality': {
                    type: 'fill',
                    paint: {
                        'fill-color': [
                            'interpolate',
                            ['linear'],
                            ['get', 'Air_Quality'],
                            0, '#edf8e9',
                            5, '#74c476',
                            10, '#238b45'
                        ],
                        'fill-opacity': 0.6,
                        'fill-outline-color': '#333333'
                    }
                },
                walkability: {
                    type: 'fill',
                    paint: {
                        'fill-color': [
                            'interpolate',
                            ['linear'],
                            ['get', 'Walkability'],
                            0, '#b4cffa',
                            5, '#5291f7',
                            10, '#0961ed'
                        ],
                        'fill-opacity': 0.6,
                        'fill-outline-color': '#333333'
                    }
                }
            };
            
            return configs[dataType] || configs.properties;
        }
        
        // Create popup content
        function createPopup(dataType, feature) {
            const props = feature.properties;
            
            switch (dataType) {
                case 'properties':
                    return `
                        <div style="font-size: 14px;">
                            <strong>Property</strong><br>
                            ${props.address || 'Address not available'}<br>
                            ${props.price ? `Price: $${props.price}` : ''}
                            ${props.type ? `<br>Type: ${props.type}` : ''}
                        </div>
                    `;
                    
                case 'socialmedia':
                    return `
                        <div style="font-size: 14px;">
                            <strong>Social Media Location</strong><br>
                            ${props.name || 'Location'}<br>
                            ${props.platform ? `Platform: ${props.platform}` : ''}
                            ${props.description ? `<br>${props.description}` : ''}
                        </div>
                    `;
                    
                case 'education':
                    return `
                        <div style="font-size: 14px;">
                            <strong>Educational Institution</strong><br>
                            ${props.name || 'Unnamed'}<br>
                            Type: ${props.amenity || 'Educational facility'}
                            ${props.operator ? `<br>Operator: ${props.operator}` : ''}
                        </div>
                    `;
                    
                case 'crime':
                    return `
                        <div style="font-size: 14px;">
                            <strong>Census Tract - Crime Data</strong><br>
                            ${props.NAME || 'Unnamed tract'}<br>
                            Crime Index: ${props.Crime || 'N/A'}/10<br>
                            GEOID: ${props.GEOID || 'N/A'}
                        </div>
                    `;
                    
                case 'air-quality':
                    return `
                        <div style="font-size: 14px;">
                            <strong>Census Tract - Air Quality</strong><br>
                            ${props.NAME || 'Unnamed tract'}<br>
                            Air Quality Index: ${props.Air_Quality || 'N/A'}/10<br>
                            GEOID: ${props.GEOID || 'N/A'}
                        </div>
                    `;
                    
                case 'walkability':
                    return `
                        <div style="font-size: 14px;">
                            <strong>Census Tract - Walkability</strong><br>
                            ${props.NAME || 'Unnamed tract'}<br>
                            Walkability Score: ${props.Walkability || 'N/A'}/10<br>
                            GEOID: ${props.GEOID || 'N/A'}
                        </div>
                    `;
                    
                default:
                    return '<div>Feature information</div>';
            }
        }
        
        // --- Filter state ---
        const filterState = {
            crime: 0,
            'air-quality': 0,
            walkability: 0
        };
        
        // --- Filter bar rendering and logic ---
        function renderFilterBar(dataType) {
            // Only for crime, air-quality, walkability
            const min = 0, max = 10;
            const value = filterState[dataType] || 0;
            let gradient = '';
            let direction = 'ltr';
            if (dataType === 'crime') {
                gradient = 'linear-gradient(90deg, #de2d26 0%, #fc9272 50%, #fee5d9 100%)';
                direction = 'rtl'; // For crime, filter from the top (high to low)
            }
            if (dataType === 'air-quality') gradient = 'linear-gradient(90deg, #edf8e9 0%, #74c476 50%, #238b45 100%)';
            if (dataType === 'walkability') gradient = 'linear-gradient(90deg, #e0f2fe 0%, #2563eb 100%)';
            // For crime, handle is from the right (high) to left (low)
            let handlePos = (value / (max - min)) * 100;
            if (dataType === 'crime') handlePos = 100 - handlePos;
            return `
                <div class="filter-bar-container">
                    <span class="filter-bar-label">Min:</span>
                    <div class="filter-bar" data-type="${dataType}" style="background: ${gradient}; direction: ${direction};">
                        <div class="filter-bar-handle" style="left: ${handlePos}%" data-type="${dataType}"></div>
                    </div>
                    <span class="filter-bar-min-label" id="filter-bar-min-label-${dataType}">${value}</span>
                </div>
            `;
        }
        
        // --- Update displayDataResults to include filter bar ---
        function displayDataResults() {
            if (Object.keys(dataResults).length === 0) {
                dataResultsEl.innerHTML = '';
                return;
            }
            let html = '';
            Object.entries(dataResults).forEach(([dataType, result]) => {
                if (result.error) {
                    html += `
                        <div class="data-results">
                            <h4>${dataType.charAt(0).toUpperCase() + dataType.slice(1).replace('-', ' ')}</h4>
                            <div class="error-message">Error: ${result.error}</div>
                        </div>
                    `;
                } else {
                    let filtered = result;
                    // Only filter for census data types
                    if (["crime", "air-quality", "walkability"].includes(dataType)) {
                        const propertyName = dataType === 'air-quality' ? 'Air_Quality' : 
                                            dataType === 'walkability' ? 'Walkability' : 'Crime';
                        filtered = result.filter(f => (f.properties[propertyName] ?? 0) >= (filterState[dataType] || 0));
                    }
                    const count = filtered.length || 0;
                    let avgValue = '';
                    if (["crime", "air-quality", "walkability"].includes(dataType) && count > 0) {
                        const propertyName = dataType === 'air-quality' ? 'Air_Quality' : 
                                           dataType === 'walkability' ? 'Walkability' : 'Crime';
                        const values = filtered.map(f => f.properties[propertyName]).filter(v => v != null);
                        if (values.length > 0) {
                            const avg = values.reduce((a, b) => a + b, 0) / values.length;
                            avgValue = `<br>Average: ${avg.toFixed(1)}/10`;
                        }
                    }
                    html += `
                        <div class="data-results">
                            <h4>${dataType.charAt(0).toUpperCase() + dataType.slice(1).replace('-', ' ')}</h4>
                            ${["crime", "air-quality", "walkability"].includes(dataType) ? renderFilterBar(dataType) : ''}
                            <div class="data-count">${count} found${avgValue}</div>
                        </div>
                    `;
                }
            });
            dataResultsEl.innerHTML = html;
            attachFilterBarHandlers();
        }
        
        function attachFilterBarHandlers() {
            document.querySelectorAll('.filter-bar').forEach(bar => {
                const dataType = bar.getAttribute('data-type');
                const handle = bar.querySelector('.filter-bar-handle');
                let dragging = false;
                let barRect = null;
                handle.addEventListener('mousedown', (e) => {
                    dragging = true;
                    handle.classList.add('active');
                    barRect = bar.getBoundingClientRect();
                    document.body.style.userSelect = 'none';
                });
                document.addEventListener('mousemove', (e) => {
                    if (!dragging) return;
                    const min = 0, max = 10;
                    let x = e.clientX - barRect.left;
                    x = Math.max(0, Math.min(barRect.width, x));
                    let value;
                    if (dataType === 'crime') {
                        // For crime, right is low, left is high
                        value = Math.round(((barRect.width - x) / barRect.width) * (max - min));
                    } else {
                        value = Math.round((x / barRect.width) * (max - min));
                    }
                    filterState[dataType] = value;
                    let handlePos = (value / (max - min)) * 100;
                    if (dataType === 'crime') handlePos = 100 - handlePos;
                    handle.style.left = `${handlePos}%`;
                    const label = document.getElementById(`filter-bar-min-label-${dataType}`);
                    if (label) label.textContent = value;
                    displayDataResults();
                    updateFilteredLayer(dataType);
                });
                document.addEventListener('mouseup', () => {
                    if (dragging) {
                        dragging = false;
                        handle.classList.remove('active');
                        document.body.style.userSelect = '';
                    }
                });
            });
        }
        
        function updateFilteredLayer(dataType) {
            // Only for census data types
            if (!["crime", "air-quality", "walkability"].includes(dataType)) return;
            const result = dataResults[dataType];
            if (!result) return;
            const propertyName = dataType === 'air-quality' ? 'Air_Quality' : 
                                dataType === 'walkability' ? 'Walkability' : 'Crime';
            const filtered = result.filter(f => (f.properties[propertyName] ?? 0) >= (filterState[dataType] || 0));
            const sourceId = `${dataType}-data`;
            if (map.getSource(sourceId)) {
                map.getSource(sourceId).setData({
                    type: 'FeatureCollection',
                    features: filtered
                });
            }
        }
        
        // Remove data layer from map
        function removeDataLayer(dataType) {
            const sourceId = `${dataType}-data`;
            const layerId = `${dataType}-layer`;
            
            if (map.getLayer(layerId)) {
                map.removeLayer(layerId);
            }
            if (map.getSource(sourceId)) {
                map.removeSource(sourceId);
            }
        }
        
        // Update UI
        function updateUI() {
            if (areaOfInterest) {
                statusEl.textContent = 'Area of Interest Saved';
                instructionsEl.textContent = 'Your area of interest has been saved. Hover over the circle to edit or select data options below.';
                areaInfoEl.innerHTML = `
                    <div class="saved-area">
                        <strong>Saved Area:</strong><br>
                        Center: ${areaOfInterest.center[1].toFixed(4)}°, ${areaOfInterest.center[0].toFixed(4)}°<br>
                        Radius: ${areaOfInterest.radius.toFixed(1)} miles
                    </div>
                `;
                clearBtn.disabled = false;
                
                // Show data options
                infoPanelEl.classList.add('expanded');
                dataOptionsEl.classList.add('visible');
            } else if (isPlacingCircle && currentCircle) {
                statusEl.textContent = 'Adjusting Circle';
                instructionsEl.textContent = 'Use mouse wheel to resize the circle. Click again to save as area of interest.';
                areaInfoEl.innerHTML = `
                    <div class="area-info">
                        <strong>Current Circle:</strong><br>
                        Radius: ${currentRadius.toFixed(1)} miles<br>
                        <em>Scroll to adjust size</em>
                    </div>
                `;
                clearBtn.disabled = true;
                
                // Hide data options
                infoPanelEl.classList.remove('expanded');
                dataOptionsEl.classList.remove('visible');
            } else {
                statusEl.textContent = 'Click anywhere on the map to start';
                instructionsEl.textContent = 'Click on the map to place a circle (25 mile radius). Use mouse wheel to resize, then click again to save.';
                areaInfoEl.innerHTML = '';
                clearBtn.disabled = true;
                
                // Hide data options
                infoPanelEl.classList.remove('expanded');
                dataOptionsEl.classList.remove('visible');
            }
        }
        
        // Map click handler
        map.on('click', (e) => {
            if (areaOfInterest) {
                return; // Don't allow new circles if one is already saved
            }
            
            if (!isPlacingCircle) {
                // First click - place circle
                currentCircle = {
                    center: [e.lngLat.lng, e.lngLat.lat],
                    radius: 25
                };
                currentRadius = 25;
                isPlacingCircle = true;
                
                updateCircle(currentCircle.center, currentRadius);
                fitMapToCircle(currentCircle.center, currentRadius);
                updateUI();
                
                // Change cursor to indicate scroll mode
                map.getCanvas().style.cursor = 'grab';
            } else {
                // Second click - save area of interest
                areaOfInterest = {
                    center: currentCircle.center,
                    radius: currentRadius
                };
                
                isPlacingCircle = false;
                currentCircle = null;
                
                // Change circle color to indicate it's saved
                map.setPaintProperty('circle-fill', 'fill-color', '#16a34a');
                map.setPaintProperty('circle-outline', 'line-color', '#16a34a');
                map.setPaintProperty('circle-fill', 'fill-opacity', 0.1);
                addCircleHoverLayer();
                
                updateUI();
                
                // Reset cursor
                map.getCanvas().style.cursor = '';
                
                console.log('Area of Interest saved:', areaOfInterest);
            }
        });
        
        // Mouse wheel handler for resizing circle
        map.on('wheel', (e) => {
            if (isPlacingCircle && currentCircle) {
                e.preventDefault();
                
                const delta = e.originalEvent.deltaY;
                const increment = delta > 0 ? -2 : 2; // Scroll down shrinks, scroll up grows
                
                currentRadius = Math.max(1, Math.min(200, currentRadius + increment)); // Limit between 1 and 200 miles
                
                updateCircle(currentCircle.center, currentRadius);
                fitMapToCircle(currentCircle.center, currentRadius);
                updateUI();
            }
        });
        
        // Clear button handler
        clearBtn.addEventListener('click', () => {
            if (map.getSource('circle')) {
                map.removeLayer('circle-fill');
                map.removeLayer('circle-outline');
                if (map.getLayer('circle-hover')) {
                    map.removeLayer('circle-hover');
                }
                map.removeSource('circle');
            }
            
            // Clear all data layers
            selectedDataTypes.forEach(dataType => {
                removeDataLayer(dataType);
            });
            
            areaOfInterest = null;
            currentCircle = null;
            isPlacingCircle = false;
            currentRadius = 25;
            selectedDataTypes.clear();
            dataResults = {};
            
            // Reset data button selections
            document.querySelectorAll('.data-button').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            updateUI();
            displayDataResults();
            map.getCanvas().style.cursor = '';
            hideEditButton();
        });
        
        // Data button handlers
        document.querySelectorAll('.data-button').forEach(button => {
            button.addEventListener('click', async () => {
                const dataType = button.getAttribute('data-type');
                
                if (!areaOfInterest) {
                    alert('Please save an area of interest first');
                    return;
                }
                
                if (selectedDataTypes.has(dataType)) {
                    selectedDataTypes.delete(dataType);
                    button.classList.remove('selected');
                    removeDataLayer(dataType);
                    delete dataResults[dataType];
                    displayDataResults();
                } else {
                    selectedDataTypes.add(dataType);
                    button.classList.add('selected');
                    await processDataType(dataType);
                }
                
                console.log('Selected data types:', Array.from(selectedDataTypes));
            });
        });
        
        // Prevent default scroll behavior on map
        map.on('wheel', (e) => {
            if (isPlacingCircle) {
                e.preventDefault();
            }
        });
        
        // Initialize UI
        updateUI();
        
        // Handle map load
        map.on('load', () => {
            console.log('Map loaded successfully');
            // Load GeoJSON data when map is ready
            loadGeoJSONData();
        });

        // Add hover and edit button logic
        let editBtn = null;
        let hovered = false;

        function showEditButton(center) {
            if (!editBtn) {
                editBtn = document.createElement('button');
                editBtn.textContent = 'Edit';
                editBtn.style.position = 'absolute';
                editBtn.style.zIndex = 1100;
                editBtn.style.background = '#2563eb';
                editBtn.style.color = 'white';
                editBtn.style.border = 'none';
                editBtn.style.borderRadius = '4px';
                editBtn.style.padding = '6px 14px';
                editBtn.style.cursor = 'pointer';
                editBtn.style.boxShadow = '0 2px 6px rgba(0,0,0,0.15)';
                editBtn.style.fontSize = '12px';
                editBtn.style.fontWeight = '500';
                editBtn.addEventListener('click', () => {
                    if (areaOfInterest) {
                        // Clear existing data layers
                        selectedDataTypes.forEach(dataType => {
                            removeDataLayer(dataType);
                        });
                        
                        currentCircle = { ...areaOfInterest };
                        currentRadius = areaOfInterest.radius;
                        isPlacingCircle = true;
                        areaOfInterest = null;
                        selectedDataTypes.clear();
                        dataResults = {};
                        
                        // Reset data button selections
                        document.querySelectorAll('.data-button').forEach(btn => {
                            btn.classList.remove('selected');
                        });
                        
                        updateCircle(currentCircle.center, currentRadius);
                        fitMapToCircle(currentCircle.center, currentRadius);
                        updateUI();
                        displayDataResults();
                        hideEditButton();
                    }
                });
                document.body.appendChild(editBtn);
            }
            
            // Convert center coordinates to screen position
            const point = map.project(center);
            editBtn.style.left = `${point.x - editBtn.offsetWidth / 2}px`;
            editBtn.style.top = `${point.y - editBtn.offsetHeight / 2}px`;
            editBtn.style.display = 'block';
        }

        function hideEditButton() {
            if (editBtn) {
                editBtn.style.display = 'none';
            }
        }

        // Add a transparent hover layer for the circle
        function addCircleHoverLayer() {
            if (!map.getLayer('circle-hover')) {
                map.addLayer({
                    id: 'circle-hover',
                    type: 'fill',
                    source: 'circle',
                    layout: {},
                    paint: {
                        'fill-color': '#000',
                        'fill-opacity': 0
                    }
                }, 'circle-outline');
            }
        }

        map.on('mousemove', (e) => {
            if (areaOfInterest && map.getLayer('circle-hover')) {
                const features = map.queryRenderedFeatures(e.point, { layers: ['circle-hover'] });
                if (features.length) {
                    if (!hovered) {
                        hovered = true;
                        showEditButton(areaOfInterest.center);
                        map.getCanvas().style.cursor = 'pointer';
                    }
                } else {
                    // Check if mouse is over edit button before hiding
                    if (hovered && editBtn && !isMouseOverEditButton(e.originalEvent)) {
                        hovered = false;
                        hideEditButton();
                        map.getCanvas().style.cursor = '';
                    }
                }
            }
        });

        function isMouseOverEditButton(mouseEvent) {
            if (!editBtn || editBtn.style.display === 'none') return false;
            const rect = editBtn.getBoundingClientRect();
            return mouseEvent.clientX >= rect.left && 
                   mouseEvent.clientX <= rect.right && 
                   mouseEvent.clientY >= rect.top && 
                   mouseEvent.clientY <= rect.bottom;
        }

        // Keep edit button visible when hovering over it
        document.addEventListener('mouseover', (e) => {
            if (e.target === editBtn) {
                hovered = true;
            }
        });

        map.on('mouseout', () => {
            // Only hide if we're actually leaving the map area
            setTimeout(() => {
                if (!hovered) {
                    hideEditButton();
                    map.getCanvas().style.cursor = '';
                }
            }, 100);
        });

    </script>
</body>
</html>